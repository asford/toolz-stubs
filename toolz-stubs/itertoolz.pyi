from typing import overload, Any, Callable, Iterable, Iterator, Mapping, List, Optional, Tuple, TypeVar, Union
from ._typing import HasGetItem, RandomLike

T = TypeVar("T")
U = TypeVar("U")
V = TypeVar("V")

HTU_ = HasGetItem[T, U]
HVU_ = HasGetItem[V, U]

HTU = TypeVar("HTU", bound=HTU_)
HVU = TypeVar("HVU", bound=HVU_)


def remove(predicate: Optional[Callable[[T], object]], seq: Iterable[T]) -> Iterator[T]: ...
@overload
def accumulate(binop: Callable[[T, T], T], seq: Iterable[T]) -> Iterable[T]: ...
@overload
def accumulate(binop: Callable[[U, T], U], seq: Iterable[T], initial: U) -> Iterable[U]: ...
@overload
def groupby(key: T, seq: Iterable[HasGetItem[T, U]]) -> Mapping[U, List[T]]: ...
@overload
def groupby(key: Callable[[T], U], seq: Iterable[T]) -> Mapping[U, List[T]]: ...
def merge_sorted(*seqs: Iterable[T], **kwargs: Any) -> Iterable[T]: ...
def interleave(seqs: Iterable[Iterable[T]]) -> Iterable[T]: ...
def unique(seq: Iterable[T], key: Optional[Callable[[T], U]] = ...) -> Iterable[T]: ...
def isiterable(x: Any) -> bool: ...
def isdistinct(seq: Iterable) -> bool: ...
def take(n: int, seq: Iterable[T]) -> Iterable[T]: ...
def tail(n: int, seq: Iterable[T]) -> Iterable[T]: ...
def drop(n: int, seq: Iterable[T]) -> Iterable[T]: ...
def take_nth(n: int, seq: Iterable[T]) -> Iterable[T]: ...
def first(seq: Iterable[T]) -> T: ...
def second(seq: Iterable[T]) -> T: ...
def nth(n: int, seq: Iterable[T]) -> T: ...
def last(seq: Iterable[T]) -> T: ...
@overload
def get(ind: List[T], seq: HasGetItem[T, U], default: U = ...) -> Tuple[U, ...]: ...  # type: ignore[misc]
@overload
def get(ind: T, seq: HasGetItem[T, U], default: U = ...) -> U: ...  # type: ignore[misc]
def concat(seqs: Iterable[Iterable[T]]) -> Iterable[T]: ...
def concatv(*seqs: Iterable[T]) -> Iterable[T]: ...
def mapcat(func: Callable[[T], Iterable[U]], seqs: Iterable[T]) -> Iterable[U]: ...
def cons(el: T, seq: Iterable[T]) -> Iterable[T]: ...
def interpose(el: T, seq: Iterable[T]) -> Iterable[T]: ...
def frequencies(seq: Iterable[T]) -> Mapping[T, int]: ...
@overload
def reduceby(key: U, binop: Callable[[T], T], seq: Iterable[HasGetItem[T, U]]) -> Mapping[U, T]: ...
@overload
def reduceby(key: U, binop: Callable[[V], T], seq: Iterable[HasGetItem[T, U]], init: V = ...) -> Mapping[U, V]: ...
@overload
def reduceby(key: Callable[[T], U], binop: Callable[[T], T], seq: Iterable[T]) -> Mapping[U, T]: ...
@overload
def reduceby(key: Callable[[T], U], binop: Callable[[V], T], seq: Iterable[T], init: V) -> Mapping[U, V]: ...
def iterate(func: Callable[[T], T], x: T) -> Iterable[T]: ...
def sliding_window(n: int, seq: Iterable[T]) -> Iterable[Tuple[T, ...]]: ...
def partition(n: int, seq: Iterable[T], pad: T = ...) -> Iterable[Tuple[T, ...]]: ...
def partition_all(n: int, seq: Iterable[T]) -> Iterable[Tuple[T, ...]]: ...
def count(seq: Iterable) -> int: ...
@overload
def pluck(ind: List[T], seqs: Iterable[HasGetItem[T, U]], default: U = ...) -> Iterable[Tuple[U]]: ...  # type: ignore[misc]
@overload
def pluck(ind: T, seqs: Iterable[HasGetItem[T, U]], default: U = ...) -> Iterable[U]: ...  # type: ignore[misc]
@overload
def join(leftkey: T, leftseq: Iterable[HTU], rightkey: V, rightseq: Iterable[HVU], left_default: HTU = ..., right_default: HVU = ...) -> Iterable[Tuple[HTU, HVU]]: ...
@overload
def join(leftkey: Callable[[T], U], leftseq: Iterable[T], rightkey: Callable[[V], U], rightseq: Iterable[V], left_default: T = ..., right_default: V = ...) -> Iterable[Tuple[T, V]]: ...
def diff(*seqs: Iterable[T], **kwargs: Any) -> Iterable[Tuple[T, ...]]: ...
def topk(k: int, seq: Iterable[T], key: Optional[Callable[[T], Any]] = ...) -> Iterable[T]: ...
def peek(seq: Iterable[T]) -> Tuple[T, Iterable[T]]: ...
def peekn(n: int, seq: Iterable[T]) -> Tuple[Tuple[T], Iterable[T]]: ...
def random_sample(prob: float, seq: Iterable[T], random_state: Optional[Union[int, RandomLike]] = ...) -> Iterable[T]: ...
@overload
def getter(index: List[T]) -> Callable[[HasGetItem[T, U]], Tuple[U]]: ...  # type: ignore[misc]
@overload
def getter(index: T) -> Callable[[HasGetItem[T, U]], U]: ...  # type: ignore[misc]
